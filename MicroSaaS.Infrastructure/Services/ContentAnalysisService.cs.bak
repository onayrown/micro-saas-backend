using MicroSaaS.Application.Interfaces.Repositories;
using MicroSaaS.Application.Interfaces.Services;
using MicroSaaS.Domain.Entities;
using MicroSaaS.Shared.Enums;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace MicroSaaS.Infrastructure.Services
{
    /// <summary>
    /// Implementação do serviço avançado de análise de conteúdo
    /// </summary>
    public class ContentAnalysisService : IContentAnalysisService
    {
        private readonly IContentPostRepository _contentRepository;
        private readonly IContentCreatorRepository _creatorRepository;
        private readonly IContentPerformanceRepository _performanceRepository;
        private readonly ISocialMediaAccountRepository _accountRepository;
        private readonly IPerformanceMetricsRepository _metricsRepository;
        private readonly ILoggingService _loggingService;

        public ContentAnalysisService(
            IContentPostRepository contentRepository,
            IContentCreatorRepository creatorRepository,
            IContentPerformanceRepository performanceRepository,
            ISocialMediaAccountRepository accountRepository,
            IPerformanceMetricsRepository metricsRepository,
            ILoggingService loggingService)
        {
            _contentRepository = contentRepository;
            _creatorRepository = creatorRepository;
            _performanceRepository = performanceRepository;
            _accountRepository = accountRepository;
            _metricsRepository = metricsRepository;
            _loggingService = loggingService;
        }

        public async Task<ContentInsightsDto> GetContentInsightsAsync(Guid contentId)
        {
            try
            {
                // Obter o conteúdo
                var content = await _contentRepository.GetByIdAsync(contentId);
                if (content == null)
                {
                    throw new ArgumentException($"Conteúdo com ID {contentId} não encontrado");
                }

                // Obter dados de performance
                var performance = await _performanceRepository.GetByContentIdAsync(contentId);
                if (performance == null)
                {
                    _loggingService.LogWarning($"Dados de performance não encontrados para o conteúdo {contentId}");
                    performance = new ContentPerformance
                    {
                        ContentId = contentId,
                        Engagement = 0,
                        Reach = 0,
                        Conversions = 0,
                        AverageViewDuration = TimeSpan.Zero,
                        Comments = 0,
                        Likes = 0,
                        Shares = 0
                    };
                }

                // Obter criador do conteúdo
                var creator = await _creatorRepository.GetByIdAsync(content.CreatorId);
                
                // Calcular pontuação geral com base em múltiplos fatores
                var overallScore = CalculateOverallScore(performance);
                
                // Analisar pontos fortes do conteúdo
                var strengthPoints = IdentifyStrengthPoints(content, performance);
                
                // Analisar sugestões de melhoria
                var improvementSuggestions = GenerateImprovementSuggestions(content, performance);
                
                // Analisar potencial viral do conteúdo
                var viralPotential = AnalyzeViralPotential(content, performance);
                
                // Analisar resposta da audiência
                var audienceResponse = AnalyzeAudienceResponse(content, performance);
                
                // Obter insights sobre competidores
                var competitorInsights = await AnalyzeCompetitorInsights(content);
                
                // Calcular desempenho por plataforma
                var platformPerformance = CalculatePlatformPerformance(content, performance);
                
                // Construir o DTO de insights completo
                var insights = new ContentInsightsDto
                {
                    ContentId = contentId,
                    Title = content.Title,
                    Summary = content.Description?.Substring(0, Math.Min(content.Description.Length, 200)) ?? "",
                    OverallScore = overallScore,
                    EngagementScore = CalculateEngagementScore(performance),
                    ReachScore = CalculateReachScore(performance),
                    ConversionScore = CalculateConversionScore(performance),
                    RetentionScore = CalculateRetentionScore(performance),
                    SentimentScore = CalculateSentimentScore(performance),
                    PerformanceFactors = IdentifyPerformanceFactors(content, performance),
                    StrengthPoints = strengthPoints,
                    ImprovementSuggestions = improvementSuggestions,
                    PlatformPerformance = platformPerformance,
                    ViralPotential = viralPotential,
                    AudienceResponse = audienceResponse,
                    KeyAttributes = IdentifyKeyAttributes(content),
                    CompetitorInsights = competitorInsights
                };

                return insights;
            }
            catch (ArgumentException)
            {
                throw;
            }
            catch (Exception ex)
            {
                _loggingService.LogError(ex, $"Erro ao analisar insights do conteúdo {contentId}");
                throw;
            }
        }

        public async Task<HighPerformancePatternDto> AnalyzeHighPerformancePatternsAsync(Guid creatorId, int topPostsCount = 20)
        {
            try
            {
                // Verificar se o criador existe
                var creator = await _creatorRepository.GetByIdAsync(creatorId);
                if (creator == null)
                {
                    throw new ArgumentException($"Criador com ID {creatorId} não encontrado");
                }

                // Obter conteúdos do criador
                var allContent = await _contentRepository.GetAllByCreatorIdAsync(creatorId);
                if (allContent == null || !allContent.Any())
                {
                    _loggingService.LogWarning($"Nenhum conteúdo encontrado para o criador {creatorId}");
                    return new HighPerformancePatternDto
                    {
                        CreatorId = creatorId,
                        IdentifiedPatterns = new List<ContentPatternDto>(),
                        TimingPatterns = new List<TimingPatternDto>(),
                        TopicPatterns = new List<TopicPatternDto>(),
                        FormatPatterns = new List<FormatPatternDto>(),
                        StylePatterns = new List<StylePatternDto>(),
                        AttributeCorrelations = new Dictionary<string, double>(),
                        HighPerformingFormats = new Dictionary<string, double>()
                    };
                }

                // Obter performance para cada conteúdo
                Dictionary<Guid, ContentPerformance> performanceByContent = new();
                foreach (var content in allContent)
                {
                    var performance = await _performanceRepository.GetByContentIdAsync(content.Id);
                    if (performance != null)
                    {
                        performanceByContent[content.Id] = performance;
                    }
                }

                // Identificar os posts de melhor desempenho
                var topPosts = allContent
                    .Where(c => performanceByContent.ContainsKey(c.Id))
                    .OrderByDescending(c => 
                        CalculateOverallContentScore(performanceByContent[c.Id]))
                    .Take(topPostsCount)
                    .ToList();

                if (!topPosts.Any())
                {
                    _loggingService.LogWarning($"Não há dados de performance suficientes para o criador {creatorId}");
                    return new HighPerformancePatternDto
                    {
                        CreatorId = creatorId,
                        IdentifiedPatterns = new List<ContentPatternDto>(),
                        TimingPatterns = new List<TimingPatternDto>(),
                        TopicPatterns = new List<TopicPatternDto>(),
                        FormatPatterns = new List<FormatPatternDto>(),
                        StylePatterns = new List<StylePatternDto>(),
                        AttributeCorrelations = new Dictionary<string, double>(),
                        HighPerformingFormats = new Dictionary<string, double>()
                    };
                }

                // Analisar padrões de tempo
                var timingPatterns = AnalyzeTimingPatterns(topPosts, performanceByContent);
                
                // Analisar padrões de tópicos
                var topicPatterns = AnalyzeTopicPatterns(topPosts, performanceByContent);
                
                // Analisar padrões de formato
                var formatPatterns = AnalyzeFormatPatterns(topPosts, performanceByContent);
                
                // Analisar padrões de estilo
                var stylePatterns = AnalyzeStylePatterns(topPosts, performanceByContent);
                
                // Identificar correlações entre atributos e performance
                var attributeCorrelations = AnalyzeAttributeCorrelations(allContent, performanceByContent);
                
                // Identificar formatos de alto desempenho
                var highPerformingFormats = IdentifyHighPerformingFormats(topPosts, performanceByContent);
                
                // Identificar padrões gerais de conteúdo
                var contentPatterns = IdentifyContentPatterns(topPosts, performanceByContent, 
                    timingPatterns, topicPatterns, formatPatterns, stylePatterns);

                // Construir e retornar o DTO completo
                return new HighPerformancePatternDto
                {
                    CreatorId = creatorId,
                    IdentifiedPatterns = contentPatterns,
                    TimingPatterns = timingPatterns,
                    TopicPatterns = topicPatterns,
                    FormatPatterns = formatPatterns,
                    StylePatterns = stylePatterns,
                    AttributeCorrelations = attributeCorrelations,
                    HighPerformingFormats = highPerformingFormats
                };
            }
            catch (ArgumentException)
            {
                throw;
            }
            catch (Exception ex)
            {
                _loggingService.LogError(ex, $"Erro ao analisar padrões de alto desempenho para o criador {creatorId}");
                throw;
            }
        }

        public async Task<ContentRecommendationsDto> GenerateContentRecommendationsAsync(Guid creatorId)
        {
            try
            {
                // Verificar se o criador existe
                var creator = await _creatorRepository.GetByIdAsync(creatorId);
                if (creator == null)
                {
                    throw new ArgumentException($"Criador com ID {creatorId} não encontrado");
                }

                // Obter conteúdos do criador
                var allContent = await _contentRepository.GetAllByCreatorIdAsync(creatorId);
                if (allContent == null || !allContent.Any())
                {
                    _loggingService.LogWarning($"Nenhum conteúdo encontrado para o criador {creatorId}");
                    return new ContentRecommendationsDto
                    {
                        ContentTopics = new List<TopicRecommendationDto>(),
                        ContentFormats = new List<FormatRecommendationDto>(),
                        ContentStrategies = new List<string>(),
                        EngagementTactics = new List<string>(),
                        MonetizationOpportunities = new List<string>()
                    };
                }

                // Obter dados de performance para cada conteúdo
                Dictionary<Guid, ContentPerformance> performanceByContent = new();
                foreach (var content in allContent)
                {
                    var performance = await _performanceRepository.GetByContentIdAsync(content.Id);
                    if (performance != null)
                    {
                        performanceByContent[content.Id] = performance;
                    }
                }

                // Obter contas sociais do criador
                var socialAccounts = await _accountRepository.GetByCreatorIdAsync(creatorId);
                var connectedPlatforms = socialAccounts
                    .Select(a => a.Platform)
                    .Distinct()
                    .ToList();

                // Analisar padrões de alto desempenho
                var perfPatterns = await AnalyzeHighPerformancePatternsAsync(creatorId);

                // Gerar recomendações de tópicos
                var topicRecommendations = GenerateTopicRecommendations(
                    allContent, 
                    performanceByContent, 
                    perfPatterns.TopicPatterns);

                // Gerar recomendações de formato
                var formatRecommendations = GenerateFormatRecommendations(
                    allContent, 
                    performanceByContent, 
                    perfPatterns.FormatPatterns,
                    connectedPlatforms);

                // Gerar estratégias de conteúdo
                var contentStrategies = GenerateContentStrategies(
                    allContent, 
                    performanceByContent, 
                    perfPatterns);

                // Gerar táticas de engajamento
                var engagementTactics = GenerateEngagementTactics(
                    allContent, 
                    performanceByContent, 
                    perfPatterns);

                // Gerar oportunidades de monetização
                var monetizationOpportunities = GenerateMonetizationOpportunities(
                    allContent, 
                    performanceByContent, 
                    creator);

                // Construir e retornar o DTO de recomendações
                return new ContentRecommendationsDto
                {
                    CreatorId = creatorId,
                    ContentTopics = topicRecommendations,
                    ContentFormats = formatRecommendations,
                    ContentStrategies = contentStrategies,
                    EngagementTactics = engagementTactics,
                    MonetizationOpportunities = monetizationOpportunities,
                    RecommendationDate = DateTime.UtcNow,
                    ConfidenceScore = CalculateConfidenceScore(allContent.Count(c => performanceByContent.ContainsKey(c.Id)))
                };
            }
            catch (ArgumentException)
            {
                throw;
            }
            catch (Exception ex)
            {
                _loggingService.LogError(ex, $"Erro ao gerar recomendações de conteúdo para o criador {creatorId}");
                throw;
            }
        }

        private List<TopicRecommendationDto> GenerateTopicRecommendations(
            List<ContentPost> allContent,
            Dictionary<Guid, ContentPerformance> performanceByContent,
            List<TopicPatternDto> topicPatterns)
        {
            var recommendations = new List<TopicRecommendationDto>();
            
            // Usar padrões de tópicos identificados para gerar recomendações
            if (topicPatterns != null && topicPatterns.Any())
            {
                // Converter padrões de tópicos em recomendações
                foreach (var pattern in topicPatterns.Take(5)) // Top 5 tópicos
                {
                    // Verificar crescimento para definir prioridade
                    var priority = pattern.GrowthTrend > 0.2 ? 
                        RecommendationPriority.High : 
                        pattern.GrowthTrend > 0 ? 
                            RecommendationPriority.Medium : 
                            RecommendationPriority.Low;
                    
                    // Gerar ideias de conteúdo baseadas no tópico
                    var contentIdeas = new List<string>();
                    
                    // Ideia 1: Baseada em tópicos relacionados
                    if (pattern.RelatedTopics.Any())
                    {
                        contentIdeas.Add($"Explore a conexão entre {pattern.TopicName} e {pattern.RelatedTopics.First()}");
                    }
                    
                    // Ideia 2: Guia/tutorial
                    contentIdeas.Add($"Crie um guia completo sobre {pattern.TopicName}");
                    
                    // Ideia 3: Tendências
                    contentIdeas.Add($"Discuta as tendências atuais em {pattern.TopicName}");
                    
                    // Ideia 4: Mitos e verdades
                    contentIdeas.Add($"Mitos e verdades sobre {pattern.TopicName}");
                    
                    // Ideia 5: Perguntas frequentes
                    contentIdeas.Add($"Responda às perguntas mais frequentes sobre {pattern.TopicName}");
                    
                    // Adicionar recomendação
                    recommendations.Add(new TopicRecommendationDto
                    {
                        TopicName = pattern.TopicName,
                        Reasoning = $"Este tópico gerou engajamento superior de {pattern.EngagementScore:P1} nos seus conteúdos anteriores" + 
                                    (pattern.GrowthTrend > 0 ? $" e mostra tendência de crescimento de {pattern.GrowthTrend:P1}" : ""),
                        Priority = priority,
                        Keywords = pattern.Keywords,
                        ContentIdeas = contentIdeas,
                        GrowthRate = pattern.GrowthTrend
                    });
                }
            }
            
            // Se não temos padrões suficientes, adicionar tópicos emergentes e tendências gerais
            if (recommendations.Count < 5)
            {
                // Em uma implementação real, buscaria tópicos em tendência de uma API externa
                // Para o MVP, usar tendências simuladas relevantes para o nicho do criador
                var emergingTopics = new List<(string Topic, string Reasoning, List<string> Keywords)>
                {
                    ("Inteligência Artificial para Criadores", 
                    "Tópico em tendência com crescimento de 85% no último trimestre", 
                    new List<string> { "IA", "automação", "ferramentas", "produtividade" }),
                    
                    ("Monetização de Conteúdo em Plataformas Emergentes", 
                    "Interesse crescente com aumento de buscas de 68% no último mês", 
                    new List<string> { "receita", "plataformas", "estratégia", "diversificação" }),
                    
                    ("Sustentabilidade e Criação Consciente", 
                    "Tema com alta ressonância entre GenZ e Millennials", 
                    new List<string> { "sustentável", "eco-friendly", "consumo consciente", "impacto" }),
                    
                    ("Narrativas Imersivas e Storytelling", 
                    "Diferencial competitivo com alto índice de retenção", 
                    new List<string> { "história", "narrativa", "storytelling", "engajamento" }),
                    
                    ("Saúde Mental para Criadores de Conteúdo", 
                    "Tema relevante com alta identificação da audiência", 
                    new List<string> { "burnout", "equilíbrio", "bem-estar", "autocuidado" })
                };
                
                // Adicionar tópicos emergentes até termos 5 recomendações
                foreach (var topic in emergingTopics)
                {
                    if (recommendations.Count >= 5) break;
                    
                    if (!recommendations.Any(r => r.TopicName.Contains(topic.Topic) || topic.Topic.Contains(r.TopicName)))
                    {
                        recommendations.Add(new TopicRecommendationDto
                        {
                            TopicName = topic.Topic,
                            Reasoning = topic.Reasoning,
                            Priority = RecommendationPriority.Medium,
                            Keywords = topic.Keywords,
                            ContentIdeas = new List<string>
                            {
                                $"Introdução a {topic.Topic}",
                                $"Como {topic.Topic} está transformando o mercado",
                                $"5 maneiras de incorporar {topic.Topic} na sua estratégia"
                            },
                            GrowthRate = 0.5 // Valor padrão para tópicos emergentes
                        });
                    }
                }
            }
            
            return recommendations;
        }

        private List<FormatRecommendationDto> GenerateFormatRecommendations(
            List<ContentPost> allContent,
            Dictionary<Guid, ContentPerformance> performanceByContent,
            List<FormatPatternDto> formatPatterns,
            List<SocialMediaPlatform> connectedPlatforms)
        {
            var recommendations = new List<FormatRecommendationDto>();
            
            // Usar padrões de formato identificados para gerar recomendações
            if (formatPatterns != null && formatPatterns.Any())
            {
                // Converter padrões de formato em recomendações
                foreach (var pattern in formatPatterns.Take(3)) // Top 3 formatos
                {
                    // Verificar se o formato é compatível com as plataformas conectadas
                    var compatiblePlatforms = pattern.BestPlatforms
                        .Intersect(connectedPlatforms)
                        .ToList();
                        
                    if (!compatiblePlatforms.Any() && connectedPlatforms.Any())
                    {
                        compatiblePlatforms = connectedPlatforms;
                    }
                    
                    // Definir prioridade com base no score de engajamento
                    var priority = pattern.EngagementScore > 0.7 ? 
                        RecommendationPriority.High : 
                        pattern.EngagementScore > 0.4 ? 
                            RecommendationPriority.Medium : 
                            RecommendationPriority.Low;
                    
                    // Adicionar recomendação
                    recommendations.Add(new FormatRecommendationDto
                    {
                        FormatName = pattern.FormatName,
                        Reasoning = $"Este formato gerou engajamento superior de {pattern.EngagementScore:P1} nos seus conteúdos anteriores",
                        Priority = priority,
                        OptimalDuration = pattern.OptimalDuration,
                        BestPractices = pattern.BestPractices,
                        RecommendedPlatforms = compatiblePlatforms
                            .Select(p => p.ToString())
                            .ToList()
                    });
                }
            }
            
            // Adicionar formatos inovadores ou formatos específicos para plataformas conectadas
            if (connectedPlatforms.Contains(SocialMediaPlatform.TikTok) && 
                !recommendations.Any(r => r.FormatName.Contains("Vídeo Curto")))
            {
                recommendations.Add(new FormatRecommendationDto
                {
                    FormatName = "Vídeo Curto Vertical",
                    Reasoning = "Formato com alta performance no TikTok, com taxas de engajamento até 30% superiores",
                CreatorId = creatorId,
                TotalAudienceSize = 0,
                GrowthRate = 0,
                DemographicBreakdown = new Dictionary<string, double>(),
                KeySegments = new List<AudienceSegmentDto>(),
                InterestDistribution = new Dictionary<string, double>(),
                PlatformEngagement = new Dictionary<SocialMediaPlatform, double>(),
                EngagementPatterns = new List<string>(),
                ContentPreferences = new Dictionary<string, double>(),
                LoyaltyMetrics = new LoyaltyMetricsDto()
            };
            
            return Task.FromResult(insights);
        }

        public Task<ContentComparisonDto> CompareContentTypesAsync(Guid creatorId, DateTime startDate, DateTime endDate)
        {
            // Implementação básica para satisfazer a interface
            _loggingService.LogWarning($"Método CompareContentTypesAsync implementado parcialmente para {creatorId}");
            
            var comparison = new ContentComparisonDto
            {
                CreatorId = creatorId,
                StartDate = startDate,
                EndDate = endDate,
                ContentTypePerformance = new Dictionary<string, ContentTypePerformanceDto>(),
                PlatformSpecificPerformance = new Dictionary<SocialMediaPlatform, List<ContentTypePerformanceDto>>(),
                CrossPlatformInsights = new List<CrossPlatformInsightDto>(),
                AttributePerformance = new Dictionary<string, double>()
            };
            
            return Task.FromResult(comparison);
        }

        public Task<ContentPredictionDto> PredictContentPerformanceAsync(ContentPredictionRequestDto request)
        {
            // Implementação básica para satisfazer a interface
            _loggingService.LogWarning($"Método PredictContentPerformanceAsync implementado parcialmente para {request.CreatorId}");
            
            var prediction = new ContentPredictionDto
            {
                RequestId = Guid.NewGuid(),
                Request = request,
                PredictedEngagementScore = 0,
                PredictedReachScore = 0,
                PredictedViralPotential = 0,
                MetricPredictions = new Dictionary<string, double>(),
                FactorConfidenceScores = new Dictionary<string, double>(),
                OptimizationSuggestions = new List<string>(),
                PredictedAudience = new PredictedAudienceResponseDto(),
                ConfidenceScore = 0.5 // Score médio para implementação básica
            };
            
            return Task.FromResult(prediction);
        }

        public Task<List<EngagementFactorDto>> IdentifyEngagementFactorsAsync(Guid creatorId)
        {
            // Implementação básica para satisfazer a interface
            _loggingService.LogWarning($"Método IdentifyEngagementFactorsAsync implementado parcialmente para {creatorId}");
            
            var factors = new List<EngagementFactorDto>
            {
                new EngagementFactorDto
                {
                    FactorName = "Qualidade do Conteúdo",
                    Importance = 0.8,
                    Description = "Relevância e valor percebido do conteúdo",
                    SubFactors = new Dictionary<string, double>
                    {
                        { "Originalidade", 0.7 },
                        { "Utilidade", 0.8 },
                        { "Clareza", 0.6 }
                    },
                    OptimizationTips = new List<string>
                    {
                        "Focar em conteúdo original e útil para a audiência",
                        "Garantir clareza e objetividade na comunicação"
                    },
                    ConfidenceScore = 0.7
                }
            };
            
            return Task.FromResult(factors);
        }

        public Task<AudienceSensitivityDto> AnalyzeAudienceSensitivityAsync(Guid creatorId)
        {
            // Implementação básica para satisfazer a interface
            _loggingService.LogWarning($"Método AnalyzeAudienceSensitivityAsync implementado parcialmente para {creatorId}");
            
            var sensitivity = new AudienceSensitivityDto
            {
                CreatorId = creatorId,
                ContentTypeSensitivity = new Dictionary<string, double>
                {
                    { "Vídeo", 0.8 },
                    { "Imagem", 0.7 },
                    { "Texto", 0.5 }
                },
                TopicSensitivity = new Dictionary<string, double>
                {
                    { "Tutorial", 0.9 },
                    { "Notícia", 0.6 },
                    { "Opinião", 0.5 }
                },
                StyleSensitivity = new Dictionary<string, double>
                {
                    { "Informal", 0.8 },
                    { "Técnico", 0.6 },
                    { "Humorístico", 0.7 }
                },
                TimingSensitivity = new Dictionary<string, double>
                {
                    { "Manhã", 0.7 },
                    { "Tarde", 0.8 },
                    { "Noite", 0.6 }
                },
                TopPreferences = new List<AudiencePreferenceDto>(),
                TopAversions = new List<AudienceAversion>(),
                OverallSensitivityScore = 0.7
            };
            
            return Task.FromResult(sensitivity);
        }

        // Métodos privados para análise de conteúdo

        private double CalculateOverallScore(ContentPerformance performance)
        {
            if (performance == null) return 0;
            
            // Pontuação baseada em uma combinação ponderada de diferentes métricas
            double engagementWeight = 0.4;
            double reachWeight = 0.3;
            double conversionWeight = 0.3;
            
            double engagementScore = CalculateEngagementScore(performance);
            double reachScore = CalculateReachScore(performance);
            double conversionScore = CalculateConversionScore(performance);
            
            return (engagementScore * engagementWeight) + 
                   (reachScore * reachWeight) + 
                   (conversionScore * conversionWeight);
        }

        private double CalculateEngagementScore(ContentPerformance performance)
        {
            if (performance == null) return 0;
            
            // Fórmula avançada para calcular engajamento considerando múltiplos fatores
            double baseEngagement = performance.Engagement;
            double commentWeight = 2.0;
            double shareWeight = 3.0;
            double likeWeight = 1.0;
            
            // Normalização para escala 0-1
            double normalizedComments = Math.Min(performance.Comments / 100.0, 1.0);
            double normalizedShares = Math.Min(performance.Shares / 50.0, 1.0);
            double normalizedLikes = Math.Min(performance.Likes / 500.0, 1.0);
            
            double weightedEngagement = (normalizedComments * commentWeight) + 
                                       (normalizedShares * shareWeight) + 
                                       (normalizedLikes * likeWeight);
            
            // Combinação de engajamento base e fatores ponderados
            return Math.Min((baseEngagement * 0.5) + (weightedEngagement * 0.5), 1.0);
        }

        private double CalculateReachScore(ContentPerformance performance)
        {
            if (performance == null) return 0;
            
            // Fórmula para calcular pontuação de alcance baseada no reach relativo
            // e crescimento orgânico
            double reach = performance.Reach;
            double normalizedReach = Math.Min(reach / 10000.0, 1.0);
            
            // Considerar crescimento orgânico (se disponível)
            double organicGrowthFactor = performance.OrganicGrowthRate > 0 ? 
                Math.Min(performance.OrganicGrowthRate / 5.0, 1.0) : 0.5;
            
            return normalizedReach * 0.7 + organicGrowthFactor * 0.3;
        }

        private double CalculateConversionScore(ContentPerformance performance)
        {
            if (performance == null || performance.Reach == 0) return 0;
            
            // Cálculo baseado na taxa de conversão (conversões / alcance)
            double conversionRate = performance.Conversions / (double)performance.Reach;
            
            // Normalizar para uma escala de 0-1, considerando que uma taxa de conversão de 5% é excelente
            return Math.Min(conversionRate * 20.0, 1.0);
        }

        private double CalculateRetentionScore(ContentPerformance performance)
        {
            if (performance == null) return 0;
            
            // Cálculo baseado no tempo médio de visualização em relação à duração total
            if (performance.ContentDuration.TotalSeconds == 0) return 0.5; // valor padrão
            
            double retentionRate = performance.AverageViewDuration.TotalSeconds / 
                                   performance.ContentDuration.TotalSeconds;
            
            // Normalizar para uma escala de 0-1
            return Math.Min(retentionRate, 1.0);
        }

        private double CalculateSentimentScore(ContentPerformance performance)
        {
            if (performance == null) return 0.5; // Neutro por padrão
            
            // Se tivermos dados de sentimento, usamos eles; caso contrário, derivamos
            // dos comentários e proporção de likes para outros tipos de interação
            
            if (performance.PositiveSentiment > 0 || performance.NegativeSentiment > 0)
            {
                double totalSentiment = performance.PositiveSentiment + performance.NegativeSentiment;
                if (totalSentiment == 0) return 0.5;
                
                return performance.PositiveSentiment / totalSentiment;
            }
            
            // Derivar sentimento da proporção de likes/dislikes se disponível
            if (performance.Dislikes > 0)
            {
                double total = performance.Likes + performance.Dislikes;
                if (total == 0) return 0.5;
                
                return performance.Likes / total;
            }
            
            // Caso não tenhamos dados diretos, estimamos com base na taxa de engajamento
            // em relação ao alcance
            if (performance.Reach > 0)
            {
                double engagementRate = performance.Engagement / (double)performance.Reach;
                // Taxas acima de 10% são consideradas muito boas
                return Math.Min(engagementRate * 10.0, 1.0);
            }
            
            return 0.5; // Valor neutro padrão
        }

        private List<string> IdentifyStrengthPoints(ContentPost content, ContentPerformance performance)
        {
            var strengths = new List<string>();
            
            if (performance == null) return strengths;
            
            // Identificar pontos fortes com base em dados de performance
            if (CalculateEngagementScore(performance) > 0.7)
            {
                strengths.Add("Alto nível de engajamento da audiência");
            }
            
            if (CalculateReachScore(performance) > 0.7)
            {
                strengths.Add("Excelente alcance orgânico");
            }
            
            if (CalculateConversionScore(performance) > 0.6)
            {
                strengths.Add("Alta taxa de conversão");
            }
            
            if (CalculateRetentionScore(performance) > 0.8)
            {
                strengths.Add("Retenção excepcional da audiência");
            }
            
            if (CalculateSentimentScore(performance) > 0.8)
            {
                strengths.Add("Sentimento fortemente positivo da audiência");
            }
            
            // Análise de conteúdo específica
            if (content.Format == ContentFormat.Video && performance.AverageViewDuration.TotalSeconds > 60)
            {
                strengths.Add("Boa duração média de visualização para vídeo");
            }
            
            if (performance.Shares > 50)
            {
                strengths.Add("Alto número de compartilhamentos, indicando valor viral");
            }
            
            if (performance.Comments > 30)
            {
                strengths.Add("Forte engajamento nos comentários");
            }
            
            // Adicionar mais pontos fortes com base na estrutura do conteúdo
            if (!string.IsNullOrEmpty(content.Headline) && content.Headline.Length < 60)
            {
                strengths.Add("Título otimizado e conciso");
            }
            
            if (content.HasCTA)
            {
                strengths.Add("Uso efetivo de call-to-action");
            }
            
            return strengths.Take(5).ToList(); // Limitar aos 5 pontos mais relevantes
        }

        private List<string> GenerateImprovementSuggestions(ContentPost content, ContentPerformance performance)
        {
            var suggestions = new List<string>();
            
            if (performance == null) return suggestions;
            
            // Gerar sugestões com base nas métricas mais fracas
            if (CalculateEngagementScore(performance) < 0.3)
            {
                suggestions.Add("Melhorar o engajamento com perguntas ou elementos interativos");
            }
            
            if (CalculateReachScore(performance) < 0.3)
            {
                suggestions.Add("Otimizar o conteúdo para maior alcance orgânico");
            }
            
            if (CalculateConversionScore(performance) < 0.2)
            {
                suggestions.Add("Fortalecer o call-to-action para aumentar conversões");
            }
            
            if (CalculateRetentionScore(performance) < 0.4)
            {
                suggestions.Add("Melhorar a retenção da audiência com storytelling mais envolvente");
            }
            
            if (CalculateSentimentScore(performance) < 0.4)
            {
                suggestions.Add("Trabalhar no tom e mensagem para melhorar o sentimento da audiência");
            }
            
            // Análise específica do tipo de conteúdo
            if (content.Format == ContentFormat.Video && performance.AverageViewDuration.TotalSeconds < 30)
            {
                suggestions.Add("Melhorar a introdução do vídeo para capturar atenção nos primeiros segundos");
            }
            
            if (performance.Shares < 10)
            {
                suggestions.Add("Adicionar elementos compartilháveis ou insights exclusivos");
            }
            
            if (string.IsNullOrEmpty(content.Headline) || content.Headline.Length > 100)
            {
                suggestions.Add("Otimizar o título para maior clareza e impacto");
            }
            
            if (!content.HasCTA)
            {
                suggestions.Add("Adicionar um call-to-action claro e direto");
            }
            
            return suggestions.Take(5).ToList(); // Limitar às 5 sugestões mais relevantes
        }

        private ViralPotentialDto AnalyzeViralPotential(ContentPost content, ContentPerformance performance)
        {
            // Analisar potencial viral do conteúdo com base em métricas chave
            double viralScore = 0.0;
            var keyFactors = new List<string>();
            var shareProbabilities = new Dictionary<string, double>();
            
            // Calcular pontuação viral com base em fatores
            if (performance != null)
            {
                // Considerar taxa de compartilhamento
                double shareRate = performance.Reach > 0 ? 
                    (double)performance.Shares / performance.Reach : 0;
                viralScore += shareRate * 3.0; // Peso maior para compartilhamentos
                
                // Considerar velocidade de crescimento inicial
                if (performance.InitialGrowthRate > 0)
                {
                    viralScore += Math.Min(performance.InitialGrowthRate / 10.0, 0.3);
                    keyFactors.Add("Alta taxa de crescimento inicial");
                }
                
                // Taxa de comentários
                double commentRate = performance.Reach > 0 ? 
                    (double)performance.Comments / performance.Reach : 0;
                viralScore += commentRate * 0.5;
                
                if (commentRate > 0.05)
                {
                    keyFactors.Add("Alta taxa de comentários");
                    shareProbabilities.Add("Baseado em comentários", Math.Min(commentRate * 10, 0.8));
                }
                
                // Taxa de likes
                double likeRate = performance.Reach > 0 ? 
                    (double)performance.Likes / performance.Reach : 0;
                viralScore += likeRate * 0.2;
                
                if (likeRate > 0.1)
                {
                    keyFactors.Add("Alta taxa de likes");
                    shareProbabilities.Add("Baseado em likes", Math.Min(likeRate * 5, 0.7));
                }
                
                // Se tem um alto sentimento positivo
                if (CalculateSentimentScore(performance) > 0.8)
                {
                    viralScore += 0.2;
                    keyFactors.Add("Sentimento fortemente positivo");
                    shareProbabilities.Add("Baseado em sentimento", 0.6);
                }
            }
            
            // Considerar fatores do próprio conteúdo
            if (content.IsEmotional)
            {
                viralScore += 0.15;
                keyFactors.Add("Conteúdo emocional");
                shareProbabilities.Add("Fator emocional", 0.55);
            }
            
            if (content.IsTrending)
            {
                viralScore += 0.15;
                keyFactors.Add("Tópico em tendência");
                shareProbabilities.Add("Fator tendência", 0.6);
            }
            
            // Limite a pontuação a 1.0
            viralScore = Math.Min(viralScore, 1.0);
            
            // Criar avaliação com base na pontuação
            string assessment = viralScore switch
            {
                > 0.8 => "Altíssimo potencial viral com probabilidade de crescimento exponencial",
                > 0.6 => "Alto potencial viral, conteúdo bem posicionado para compartilhamento",
                > 0.4 => "Potencial viral moderado, pode alcançar compartilhamentos significativos",
                > 0.2 => "Baixo potencial viral, mas com elementos promissores",
                _ => "Potencial viral limitado, precisa de ajustes para aumentar compartilhamentos"
            };
            
            return new ViralPotentialDto
            {
                Score = viralScore,
                Assessment = assessment,
                KeyFactors = keyFactors,
                ShareProbabilities = shareProbabilities
            };
        }

        private AudienceResponseDto AnalyzeAudienceResponse(ContentPost content, ContentPerformance performance)
        {
            var response = new AudienceResponseDto
            {
                PositiveSentiment = 0.6, // Valor padrão
                NegativeSentiment = 0.2, // Valor padrão
                NeutralSentiment = 0.2,  // Valor padrão
                CommonFeedback = new List<string>(),
                DemographicBreakdown = new List<DemographicResponseDto>()
            };
            
            if (performance == null) return response;
            
            // Se temos dados diretos de sentimento, usamos eles
            if (performance.PositiveSentiment > 0 || performance.NegativeSentiment > 0)
            {
                double total = performance.PositiveSentiment + performance.NegativeSentiment;
                if (total > 0)
                {
                    response.PositiveSentiment = performance.PositiveSentiment / total;
                    response.NegativeSentiment = performance.NegativeSentiment / total;
                    response.NeutralSentiment = Math.Max(0, 1 - response.PositiveSentiment - response.NegativeSentiment);
                }
            }
            
            // Adicionar feedback comum baseado nas estatísticas
            if (performance.Likes > 100)
            {
                response.CommonFeedback.Add("Conteúdo muito apreciado pela audiência");
            }
            
            if (performance.Comments > 50)
            {
                response.CommonFeedback.Add("Gerou discussão significativa");
            }
            
            if (performance.Reach > 5000 && performance.Engagement < 100)
            {
                response.CommonFeedback.Add("Alcançou muitos usuários, mas com engajamento proporcionalmente baixo");
            }
            
            if (performance.AverageViewDuration.TotalSeconds > 60)
            {
                response.CommonFeedback.Add("Boa retenção, indicando conteúdo envolvente");
            }
            
            // Adicionar breakdown demográfico simulado (em uma implementação real, viria de dados)
            response.DemographicBreakdown.Add(new DemographicResponseDto
            {
                Demographic = "18-24 anos",
                EngagementRate = 0.15,
                ResponseType = "Muito Positivo"
            });
            
            response.DemographicBreakdown.Add(new DemographicResponseDto
            {
                Demographic = "25-34 anos",
                EngagementRate = 0.22,
                ResponseType = "Positivo"
            });
            
            response.DemographicBreakdown.Add(new DemographicResponseDto
            {
                Demographic = "35-44 anos",
                EngagementRate = 0.18,
                ResponseType = "Neutro"
            });
            
            return response;
        }

        private async Task<List<CompetitorInsightDto>> AnalyzeCompetitorInsights(ContentPost content)
        {
            var insights = new List<CompetitorInsightDto>();
            
            try
            {
                // Buscar conteúdos similares de outros criadores
                // Em uma implementação real, isso envolveria análise de tópicos semelhantes
                // e comparação com conteúdo de concorrentes
                
                // Simular dados para o MVP
                insights.Add(new CompetitorInsightDto
                {
                    CompetitorName = "Criador Semelhante A",
                    RelativePerformance = 1.2, // 20% melhor
                    DifferentiatingFactors = new List<string>
                    {
                        "Títulos mais diretos e impactantes",
                        "Maior uso de elementos visuais"
                    }
                });
                
                insights.Add(new CompetitorInsightDto
                {
                    CompetitorName = "Criador Semelhante B",
                    RelativePerformance = 0.8, // 20% pior
                    DifferentiatingFactors = new List<string>
                    {
                        "Menor duração de conteúdo",
                        "Maior frequência de postagem"
                    }
                });
                
                return insights;
            }
            catch (Exception ex)
            {
                _loggingService.LogWarning(ex, "Erro ao analisar insights de competidores");
                return insights; // Retornar lista vazia em caso de erro
            }
        }

        private Dictionary<string, double> IdentifyPerformanceFactors(ContentPost content, ContentPerformance performance)
        {
            var factors = new Dictionary<string, double>();
            
            if (performance == null) return factors;
            
            // Identificar fatores que contribuem para performance e suas pontuações relativas
            
            // Calcular fator de engajamento
            if (performance.Reach > 0)
            {
                double engagementRate = (double)performance.Engagement / performance.Reach;
                factors.Add("Taxa de Engajamento", Math.Min(engagementRate * 10, 1.0));
            }
            
            // Fator de comentários
            if (performance.Reach > 0)
            {
                double commentRate = (double)performance.Comments / performance.Reach;
                factors.Add("Taxa de Comentários", Math.Min(commentRate * 20, 1.0));
            }
            
            // Fator de compartilhamentos
            if (performance.Reach > 0)
            {
                double shareRate = (double)performance.Shares / performance.Reach;
                factors.Add("Taxa de Compartilhamento", Math.Min(shareRate * 30, 1.0));
            }
            
            // Fator de tempo de visualização
            if (content.Format == ContentFormat.Video && performance.ContentDuration.TotalSeconds > 0)
            {
                double viewRatio = performance.AverageViewDuration.TotalSeconds / 
                                   performance.ContentDuration.TotalSeconds;
                factors.Add("Retenção de Visualização", Math.Min(viewRatio, 1.0));
            }
            
            // Fator de conversão
            if (performance.Reach > 0)
            {
                double conversionRate = (double)performance.Conversions / performance.Reach;
                factors.Add("Taxa de Conversão", Math.Min(conversionRate * 20, 1.0));
            }
            
            // Fator de crescimento
            if (performance.InitialGrowthRate > 0)
            {
                factors.Add("Taxa de Crescimento", Math.Min(performance.InitialGrowthRate / 10.0, 1.0));
            }
            
            return factors;
        }

        private List<string> IdentifyKeyAttributes(ContentPost content)
        {
            var attributes = new List<string>();
            
            // Identificar atributos-chave do conteúdo
            if (content == null) return attributes;
            
            // Adicionar formato
            attributes.Add($"Formato: {content.Format}");
            
            // Adicionar duração se for vídeo ou áudio
            if (content.Format == ContentFormat.Video || content.Format == ContentFormat.Audio)
            {
                string duration = content.Duration.TotalMinutes > 1 
                    ? $"{content.Duration.TotalMinutes:0.0} minutos" 
                    : $"{content.Duration.TotalSeconds:0} segundos";
                attributes.Add($"Duração: {duration}");
            }
            
            // Adicionar tópico principal
            if (!string.IsNullOrEmpty(content.PrimaryTopic))
            {
                attributes.Add($"Tópico: {content.PrimaryTopic}");
            }
            
            // Adicionar tom/estilo
            if (!string.IsNullOrEmpty(content.ContentStyle))
            {
                attributes.Add($"Estilo: {content.ContentStyle}");
            }
            
            // Adicionar se tem call-to-action
            if (content.HasCTA)
            {
                attributes.Add("Contém Call-to-Action");
            }
            
            // Adicionar se é conteúdo emocional
            if (content.IsEmotional)
            {
                attributes.Add("Conteúdo Emocional");
            }
            
            // Adicionar se é conteúdo educacional
            if (content.IsEducational)
            {
                attributes.Add("Conteúdo Educacional");
            }
            
            // Adicionar se é conteúdo em tendência
            if (content.IsTrending)
            {
                attributes.Add("Tópico em Tendência");
            }
            
            return attributes;
        }

        private Dictionary<SocialMediaPlatform, double> CalculatePlatformPerformance(ContentPost content, ContentPerformance performance)
        {
            var platformPerformance = new Dictionary<SocialMediaPlatform, double>();
            
            if (performance == null || performance.PlatformMetrics == null) 
            {
                // Adicionar desempenho da plataforma principal do conteúdo
                if (content != null && content.Platform != SocialMediaPlatform.None)
                {
                    platformPerformance.Add(content.Platform, 0.5); // valor padrão
                }
                return platformPerformance;
            }
            
            // Percorrer métricas por plataforma e calcular desempenho normalizado
            foreach (var platformMetric in performance.PlatformMetrics)
            {
                double platformScore = 0.0;
                var metric = platformMetric.Value;
                
                // Cálculo específico por plataforma, considerando métricos relevantes
                switch (platformMetric.Key)
                {
                    case SocialMediaPlatform.Instagram:
                        // Instagram: prioriza engajamento e alcance
                        platformScore = (CalculateMetricScore(metric.Engagement, 1000) * 0.5) +
                                      (CalculateMetricScore(metric.Reach, 5000) * 0.3) +
                                      (CalculateMetricScore(metric.Likes, 500) * 0.2);
                        break;
                        
                    case SocialMediaPlatform.YouTube:
                        // YouTube: prioriza tempo de visualização e retenção
                        double retentionRate = metric.ContentDuration.TotalSeconds > 0 ?
                            metric.AverageViewDuration.TotalSeconds / metric.ContentDuration.TotalSeconds : 0;
                        
                        platformScore = (CalculateMetricScore(metric.Views, 1000) * 0.3) +
                                      (retentionRate * 0.4) +
                                      (CalculateMetricScore(metric.Comments, 50) * 0.3);
                        break;
                        
                    case SocialMediaPlatform.TikTok:
                        // TikTok: prioriza visualizações e compartilhamentos
                        platformScore = (CalculateMetricScore(metric.Views, 10000) * 0.4) +
                                      (CalculateMetricScore(metric.Shares, 100) * 0.4) +
                                      (CalculateMetricScore(metric.Comments, 100) * 0.2);
                        break;
                        
                    default:
                        // Outras plataformas: cálculo genérico
                        platformScore = (CalculateMetricScore(metric.Engagement, 500) * 0.4) +
                                      (CalculateMetricScore(metric.Reach, 2000) * 0.4) +
                                      (CalculateMetricScore(metric.Likes, 200) * 0.2);
                        break;
                }
                
                platformPerformance.Add(platformMetric.Key, Math.Min(platformScore, 1.0));
            }
            
            return platformPerformance;
        }

        private double CalculateMetricScore(int value, int benchmark)
        {
            // Calcular pontuação normalizada para uma métrica
            // onde benchmark é o valor considerado "bom" (0.7 na escala)
            if (benchmark <= 0) return 0;
            
            double ratio = (double)value / benchmark;
            
            // Transformação logística para normalizar entre 0 e 1
            // com crescimento mais rápido em torno do benchmark
            return 1.0 / (1.0 + Math.Exp(-5 * (ratio - 0.7)));
        }

        private double CalculateOverallContentScore(ContentPerformance performance)
        {
            if (performance == null) return 0;
            
            // Pontuação ponderada com base nas diferentes métricas
            double engagementWeight = 0.4;
            double reachWeight = 0.3;
            double conversionWeight = 0.2;
            double growthWeight = 0.1;
            
            // Normalizar métricas para uma escala de 0-1
            double normalizedEngagement = NormalizeMetric(performance.Engagement, 500);
            double normalizedReach = NormalizeMetric(performance.Reach, 10000);
            double normalizedConversions = NormalizeMetric(performance.Conversions, 50);
            double normalizedGrowth = performance.InitialGrowthRate > 0 
                ? Math.Min(performance.InitialGrowthRate / 5.0, 1.0) : 0;
            
            // Calcular pontuação final
            return (normalizedEngagement * engagementWeight) +
                   (normalizedReach * reachWeight) +
                   (normalizedConversions * conversionWeight) +
                   (normalizedGrowth * growthWeight);
        }

        private double NormalizeMetric(int value, int benchmark)
        {
            if (benchmark <= 0) return 0;
            double ratio = (double)value / benchmark;
            return Math.Min(ratio, 1.0);
        }

        private List<TimingPatternDto> AnalyzeTimingPatterns(
            List<ContentPost> topPosts, 
            Dictionary<Guid, ContentPerformance> performanceByContent)
        {
            var patterns = new List<TimingPatternDto>();
            
            // Contadores para dias da semana
            var dayPerformance = new Dictionary<DayOfWeek, (double Score, int Count)>();
            foreach (DayOfWeek day in Enum.GetValues(typeof(DayOfWeek)))
            {
                dayPerformance[day] = (0, 0);
            }
            
            // Contadores para horários (24h)
            var hourlyPerformance = new Dictionary<int, (double Score, int Count)>();
            for (int i = 0; i < 24; i++)
            {
                hourlyPerformance[i] = (0, 0);
            }
            
            // Contadores específicos por plataforma
            var platformTimings = new Dictionary<SocialMediaPlatform, Dictionary<(DayOfWeek, int), (double Score, int Count)>>();
            
            // Analisar cada post de alto desempenho
            foreach (var post in topPosts)
            {
                if (!performanceByContent.ContainsKey(post.Id)) continue;
                
                var performance = performanceByContent[post.Id];
                var score = CalculateOverallContentScore(performance);
                
                // Incrementar contadores para dia da semana
                var day = post.PublishedAt.DayOfWeek;
                var currentDayValue = dayPerformance[day];
                dayPerformance[day] = (currentDayValue.Score + score, currentDayValue.Count + 1);
                
                // Incrementar contadores para hora do dia
                var hour = post.PublishedAt.Hour;
                var currentHourValue = hourlyPerformance[hour];
                hourlyPerformance[hour] = (currentHourValue.Score + score, currentHourValue.Count + 1);
                
                // Incrementar contadores específicos da plataforma
                var platform = post.Platform;
                if (platform != SocialMediaPlatform.None)
                {
                    if (!platformTimings.ContainsKey(platform))
                    {
                        platformTimings[platform] = new Dictionary<(DayOfWeek, int), (double Score, int Count)>();
                    }
                    
                    var key = (day, hour);
                    if (!platformTimings[platform].ContainsKey(key))
                    {
                        platformTimings[platform][key] = (0, 0);
                    }
                    
                    var currentValue = platformTimings[platform][key];
                    platformTimings[platform][key] = (currentValue.Score + score, currentValue.Count + 1);
                }
            }
            
            // Identificar os melhores dias
            var bestDays = dayPerformance
                .Where(kv => kv.Value.Count > 0)
                .OrderByDescending(kv => kv.Value.Score / kv.Value.Count)
                .Take(3)
                .Select(kv => kv.Key)
                .ToList();
            
            // Identificar os melhores horários
            var bestHours = hourlyPerformance
                .Where(kv => kv.Value.Count > 0)
                .OrderByDescending(kv => kv.Value.Score / kv.Value.Count)
                .Take(3)
                .Select(kv => new TimeSpan(kv.Key, 0, 0))
                .ToList();
            
            // Criar padrões específicos por plataforma
            var platformSpecificTimes = new Dictionary<SocialMediaPlatform, List<BestTimeSlotDto>>();
            foreach (var platform in platformTimings.Keys)
            {
                var bestSlots = platformTimings[platform]
                    .Where(kv => kv.Value.Count > 0)
                    .OrderByDescending(kv => kv.Value.Score / kv.Value.Count)
                    .Take(3)
                    .Select(kv => new BestTimeSlotDto
                    {
                        Day = kv.Key.Item1,
                        Time = new TimeSpan(kv.Key.Item2, 0, 0),
                        EngagementScore = kv.Value.Score / kv.Value.Count,
                        Rationale = $"Alto engajamento observado em {kv.Value.Count} posts"
                    })
                    .ToList();
                
                if (bestSlots.Any())
                {
                    platformSpecificTimes[platform] = bestSlots;
                }
            }
            
            // Criar o padrão de tempo global
            var pattern = new TimingPatternDto
            {
                BestDays = bestDays,
                BestTimes = bestHours,
                PlatformSpecificTimes = platformSpecificTimes,
                ConfidenceScore = CalculateConfidenceScore(topPosts.Count)
            };
            
            patterns.Add(pattern);
            
            return patterns;
        }

        private List<TopicPatternDto> AnalyzeTopicPatterns(
            List<ContentPost> topPosts, 
            Dictionary<Guid, ContentPerformance> performanceByContent)
        {
            var topicPerformance = new Dictionary<string, (double TotalScore, int Count, List<Guid> ExampleIds)>();
            
            // Analisar cada post de alto desempenho
            foreach (var post in topPosts)
            {
                if (!performanceByContent.ContainsKey(post.Id) || string.IsNullOrEmpty(post.PrimaryTopic)) 
                    continue;
                
                var performance = performanceByContent[post.Id];
                var score = CalculateOverallContentScore(performance);
                
                // Incrementar contador para o tópico principal
                if (!topicPerformance.ContainsKey(post.PrimaryTopic))
                {
                    topicPerformance[post.PrimaryTopic] = (0, 0, new List<Guid>());
                }
                
                var current = topicPerformance[post.PrimaryTopic];
                topicPerformance[post.PrimaryTopic] = 
                    (current.TotalScore + score, current.Count + 1, current.ExampleIds.Append(post.Id).ToList());
                
                // Processar tópicos secundários se disponíveis
                if (post.SecondaryTopics != null)
                {
                    foreach (var topic in post.SecondaryTopics)
                    {
                        if (string.IsNullOrEmpty(topic)) continue;
                        
                        if (!topicPerformance.ContainsKey(topic))
                        {
                            topicPerformance[topic] = (0, 0, new List<Guid>());
                        }
                        
                        var currentSecondary = topicPerformance[topic];
                        topicPerformance[topic] = 
                            (currentSecondary.TotalScore + (score * 0.7), // Peso menor para tópicos secundários
                             currentSecondary.Count + 1,
                             currentSecondary.ExampleIds.Append(post.Id).ToList());
                    }
                }
            }
            
            // Calcular tendências de crescimento (simuladas para o MVP)
            var growthTrends = new Dictionary<string, double>();
            foreach (var topic in topicPerformance.Keys)
            {
                // Simular tendência de crescimento entre -0.2 e 0.5
                growthTrends[topic] = Math.Max(-0.2, Math.Min(0.5, (new Random().NextDouble() * 0.7) - 0.2));
            }
            
            // Identificar tópicos relacionados
            var relatedTopics = new Dictionary<string, List<string>>();
            foreach (var mainTopic in topicPerformance.Keys)
            {
                var related = new List<string>();
                
                // Encontrar posts que contêm este tópico
                var postsWithTopic = topPosts.Where(p => 
                    p.PrimaryTopic == mainTopic || 
                    (p.SecondaryTopics != null && p.SecondaryTopics.Contains(mainTopic)))
                    .ToList();
                
                // Coletar outros tópicos presentes nestes posts
                foreach (var post in postsWithTopic)
                {
                    if (post.PrimaryTopic != mainTopic && !string.IsNullOrEmpty(post.PrimaryTopic))
                    {
                        related.Add(post.PrimaryTopic);
                    }
                    
                    if (post.SecondaryTopics != null)
                    {
                        foreach (var topic in post.SecondaryTopics)
                        {
                            if (topic != mainTopic && !string.IsNullOrEmpty(topic))
                            {
                                related.Add(topic);
                            }
                        }
                    }
                }
                
                // Armazenar tópicos relacionados (sem duplicatas)
                relatedTopics[mainTopic] = related.Distinct().Take(5).ToList();
            }
            
            // Identificar palavras-chave associadas a cada tópico
            var keywords = new Dictionary<string, List<string>>();
            foreach (var topic in topicPerformance.Keys)
            {
                // Para o MVP, usamos dados simulados
                // Em uma implementação real, analisaríamos o conteúdo do texto
                keywords[topic] = GenerateSimulatedKeywords(topic, 5);
            }
            
            // Criar DTOs de padrões de tópicos
            var patterns = topicPerformance
                .Where(kv => kv.Value.Count >= 2) // Pelo menos 2 posts para formar um padrão
                .OrderByDescending(kv => kv.Value.TotalScore / kv.Value.Count)
                .Take(10) // Top 10 tópicos
                .Select(kv => new TopicPatternDto
                {
                    TopicName = kv.Key,
                    EngagementScore = kv.Value.TotalScore / kv.Value.Count,
                    GrowthTrend = growthTrends.ContainsKey(kv.Key) ? growthTrends[kv.Key] : 0,
                    RelatedTopics = relatedTopics.ContainsKey(kv.Key) ? relatedTopics[kv.Key] : new List<string>(),
                    Keywords = keywords.ContainsKey(kv.Key) ? keywords[kv.Key] : new List<string>()
                })
                .ToList();
            
            return patterns;
        }

        private List<string> GenerateSimulatedKeywords(string topic, int count)
        {
            // Simular palavras-chave relacionadas ao tópico
            // Em uma implementação real, usaríamos NLP ou dados reais
            var baseKeywords = new Dictionary<string, List<string>>
            {
                ["tecnologia"] = new List<string> { "inovação", "digital", "futuro", "dispositivos", "gadgets", "apps" },
                ["viagem"] = new List<string> { "destinos", "aventura", "hotel", "passagens", "turismo", "férias" },
                ["culinária"] = new List<string> { "receitas", "gastronomia", "pratos", "ingredientes", "cozinha", "chef" },
                ["moda"] = new List<string> { "tendências", "estilo", "roupas", "acessórios", "desfile", "fashion" },
                ["fitness"] = new List<string> { "exercício", "saúde", "treino", "academia", "dieta", "bem-estar" },
                ["negócios"] = new List<string> { "empreendedorismo", "carreira", "mercado", "investimento", "estratégia" }
            };
            
            // Encontrar palavras-chave para o tópico
            foreach (var key in baseKeywords.Keys)
            {
                if (topic.ToLower().Contains(key) || key.Contains(topic.ToLower()))
                {
                    return baseKeywords[key].Take(count).ToList();
                }
            }
            
            // Palavras-chave genéricas para tópicos não mapeados
            return new List<string> 
            { 
                $"{topic} tendências", 
                $"dicas de {topic}", 
                $"como melhorar {topic}", 
                $"{topic} avançado",
                $"{topic} para iniciantes"
            }.Take(count).ToList();
        }

        private double CalculateConfidenceScore(int sampleSize)
        {
            // Calcular pontuação de confiança baseada no tamanho da amostra
            // Menos de 5 amostras -> baixa confiança
            // 5-10 amostras -> confiança média
            // Mais de 10 amostras -> alta confiança
            if (sampleSize < 5) return 0.3;
            if (sampleSize < 10) return 0.6;
            return 0.9;
        }

        private List<FormatPatternDto> AnalyzeFormatPatterns(
            List<ContentPost> topPosts, 
            Dictionary<Guid, ContentPerformance> performanceByContent)
        {
            var formatPerformance = new Dictionary<ContentFormat, (double TotalScore, int Count)>();
            var formatPlatforms = new Dictionary<ContentFormat, Dictionary<SocialMediaPlatform, int>>();
            var formatDurations = new Dictionary<ContentFormat, List<TimeSpan>>();
            var formatBestPractices = new Dictionary<ContentFormat, HashSet<string>>();
            
            // Inicializar contadores para todos os formatos
            foreach (ContentFormat format in Enum.GetValues(typeof(ContentFormat)))
            {
                formatPerformance[format] = (0, 0);
                formatPlatforms[format] = new Dictionary<SocialMediaPlatform, int>();
                formatDurations[format] = new List<TimeSpan>();
                formatBestPractices[format] = new HashSet<string>();
            }
            
            // Analisar cada post de alto desempenho
            foreach (var post in topPosts)
            {
                if (!performanceByContent.ContainsKey(post.Id)) continue;
                
                var performance = performanceByContent[post.Id];
                var score = CalculateOverallContentScore(performance);
                var format = post.Format;
                
                // Incrementar contador para o formato
                var current = formatPerformance[format];
                formatPerformance[format] = (current.TotalScore + score, current.Count + 1);
                
                // Registrar plataforma
                if (post.Platform != SocialMediaPlatform.None)
                {
                    if (!formatPlatforms[format].ContainsKey(post.Platform))
                    {
                        formatPlatforms[format][post.Platform] = 0;
                    }
                    formatPlatforms[format][post.Platform]++;
                }
                
                // Registrar duração (principalmente para vídeo e áudio)
                if (post.Duration > TimeSpan.Zero)
                {
                    formatDurations[format].Add(post.Duration);
                }
                
                // Identificar práticas recomendadas
                if (performance.EngagementRate > 0.1) // Alta taxa de engajamento
                {
                    if (post.HasCTA)
                    {
                        formatBestPractices[format].Add("Inclusão de call-to-action eficaz");
                    }
                    
                    if (post.IsEducational)
                    {
                        formatBestPractices[format].Add("Conteúdo educacional que agrega valor");
                    }
                    
                    if (post.IsEmotional)
                    {
                        formatBestPractices[format].Add("Apelo emocional eficaz");
                    }
                    
                    if (!string.IsNullOrEmpty(post.Headline) && post.Headline.Length < 60)
                    {
                        formatBestPractices[format].Add("Título conciso e impactante");
                    }
                    
                    if (format == ContentFormat.Video && performance.AverageViewDuration.TotalSeconds > 60)
                    {
                        formatBestPractices[format].Add("Introdução envolvente que mantém a audiência");
                    }
                }
            }
            
            // Criar DTOs de padrões de formato
            var patterns = formatPerformance
                .Where(kv => kv.Value.Count > 0 && kv.Key != ContentFormat.None) // Apenas formatos com dados
                .OrderByDescending(kv => kv.Value.TotalScore / kv.Value.Count)
                .Select(kv => 
                {
                    var format = kv.Key;
                    
                    // Determinar duração ótima
                    string optimalDuration = "N/A";
                    if (formatDurations[format].Any())
                    {
                        var avgDuration = new TimeSpan(
                            (long)formatDurations[format].Average(d => d.Ticks));
                        
                        optimalDuration = avgDuration.TotalMinutes >= 1
                            ? $"{avgDuration.TotalMinutes:0.0} minutos"
                            : $"{avgDuration.TotalSeconds:0} segundos";
                    }
                    
                    // Determinar melhores plataformas
                    var bestPlatforms = formatPlatforms[format]
                        .OrderByDescending(kv => kv.Value)
                        .Take(3)
                        .Select(kv => kv.Key)
                        .ToList();
                    
                    return new FormatPatternDto
                    {
                        FormatName = format.ToString(),
                        EngagementScore = kv.Value.TotalScore / kv.Value.Count,
                        BestPlatforms = bestPlatforms,
                        OptimalDuration = optimalDuration,
                        BestPractices = formatBestPractices[format].ToList()
                    };
                })
                .ToList();
            
            return patterns;
        }

        private List<StylePatternDto> AnalyzeStylePatterns(
            List<ContentPost> topPosts, 
            Dictionary<Guid, ContentPerformance> performanceByContent)
        {
            var stylePerformance = new Dictionary<string, (double TotalScore, int Count, List<string> Characteristics)>();
            
            // Analisar cada post de alto desempenho
            foreach (var post in topPosts)
            {
                if (!performanceByContent.ContainsKey(post.Id) || string.IsNullOrEmpty(post.ContentStyle)) 
                    continue;
                
                var performance = performanceByContent[post.Id];
                var score = CalculateOverallContentScore(performance);
                var style = post.ContentStyle;
                
                // Registrar características do estilo
                var characteristics = new List<string>();
                
                if (post.IsEducational)
                {
                    characteristics.Add("Educacional");
                }
                
                if (post.IsEmotional)
                {
                    characteristics.Add("Emocional");
                }
                
                if (post.IsHumorous)
                {
                    characteristics.Add("Humorístico");
                }
                
                if (post.IsInspirational)
                {
                    characteristics.Add("Inspirador");
                }
                
                if (post.HasCTA)
                {
                    characteristics.Add("Com call-to-action");
                }
                
                // Incrementar contador para o estilo
                if (!stylePerformance.ContainsKey(style))
                {
                    stylePerformance[style] = (0, 0, new List<string>());
                }
                
                var current = stylePerformance[style];
                
                // Mesclar características
                var combinedCharacteristics = current.Characteristics.Concat(characteristics).Distinct().ToList();
                
                stylePerformance[style] = 
                    (current.TotalScore + score, current.Count + 1, combinedCharacteristics);
            }
            
            // Criar DTOs de padrões de estilo
            var patterns = stylePerformance
                .Where(kv => kv.Value.Count >= 2) // Pelo menos 2 posts para formar um padrão
                .OrderByDescending(kv => kv.Value.TotalScore / kv.Value.Count)
                .Take(5) // Top 5 estilos
                .Select(kv => new StylePatternDto
                {
                    StyleName = kv.Key,
                    Description = GenerateStyleDescription(kv.Key, kv.Value.Characteristics),
                    AudienceReception = kv.Value.TotalScore / kv.Value.Count,
                    KeyCharacteristics = kv.Value.Characteristics.Take(5).ToList()
                })
                .ToList();
            
            return patterns;
        }

        private string GenerateStyleDescription(string style, List<string> characteristics)
        {
            // Gerar descrição do estilo com base em suas características
            var description = $"Estilo {style} caracterizado por ";
            
            if (characteristics.Any())
            {
                description += $"conteúdo {string.Join(", ", characteristics)}";
            }
            else
            {
                description += "abordagem única e consistente";
            }
            
            return description;
        }

        private Dictionary<string, double> AnalyzeAttributeCorrelations(
            List<ContentPost> allContent, 
            Dictionary<Guid, ContentPerformance> performanceByContent)
        {
            var correlations = new Dictionary<string, double>();
            
            // Para cada atributo, calcular correlação com performance
            // Formato
            CalculateAttributeCorrelation("Formato: Vídeo", c => c.Format == ContentFormat.Video);
            CalculateAttributeCorrelation("Formato: Imagem", c => c.Format == ContentFormat.Image);
            CalculateAttributeCorrelation("Formato: Texto", c => c.Format == ContentFormat.Text);
            CalculateAttributeCorrelation("Formato: Carrossel", c => c.Format == ContentFormat.Carousel);
            
            // Plataforma
            CalculateAttributeCorrelation("Plataforma: Instagram", c => c.Platform == SocialMediaPlatform.Instagram);
            CalculateAttributeCorrelation("Plataforma: YouTube", c => c.Platform == SocialMediaPlatform.YouTube);
            CalculateAttributeCorrelation("Plataforma: TikTok", c => c.Platform == SocialMediaPlatform.TikTok);
            
            // Características gerais
            CalculateAttributeCorrelation("Com CTA", c => c.HasCTA);
            CalculateAttributeCorrelation("Conteúdo Educacional", c => c.IsEducational);
            CalculateAttributeCorrelation("Conteúdo Emocional", c => c.IsEmotional);
            CalculateAttributeCorrelation("Conteúdo Humorístico", c => c.IsHumorous);
            CalculateAttributeCorrelation("Conteúdo Inspirador", c => c.IsInspirational);
            CalculateAttributeCorrelation("Tópico em Tendência", c => c.IsTrending);
            
            // Duração (para vídeo/áudio)
            CalculateAttributeCorrelation("Duração < 1 min", 
                c => c.Format == ContentFormat.Video && c.Duration.TotalMinutes < 1);
            CalculateAttributeCorrelation("Duração 1-3 min", 
                c => c.Format == ContentFormat.Video && c.Duration.TotalMinutes >= 1 && c.Duration.TotalMinutes < 3);
            CalculateAttributeCorrelation("Duração > 3 min", 
                c => c.Format == ContentFormat.Video && c.Duration.TotalMinutes >= 3);
            
            // Horário de publicação
            CalculateAttributeCorrelation("Publicado: Manhã (6-12h)", 
                c => c.PublishedAt.Hour >= 6 && c.PublishedAt.Hour < 12);
            CalculateAttributeCorrelation("Publicado: Tarde (12-18h)", 
                c => c.PublishedAt.Hour >= 12 && c.PublishedAt.Hour < 18);
            CalculateAttributeCorrelation("Publicado: Noite (18-23h)", 
                c => c.PublishedAt.Hour >= 18 && c.PublishedAt.Hour < 23);
            
            // Dia da semana
            CalculateAttributeCorrelation("Publicado: Fim de semana", 
                c => c.PublishedAt.DayOfWeek == DayOfWeek.Saturday || c.PublishedAt.DayOfWeek == DayOfWeek.Sunday);
            CalculateAttributeCorrelation("Publicado: Dia útil", 
                c => c.PublishedAt.DayOfWeek != DayOfWeek.Saturday && c.PublishedAt.DayOfWeek != DayOfWeek.Sunday);
            
            return correlations
                .OrderByDescending(kv => Math.Abs(kv.Value)) // Ordenar por magnitude da correlação
                .Take(15) // Top 15 correlações mais fortes
                .ToDictionary(kv => kv.Key, kv => kv.Value);
            
            // Função local para calcular correlação
            void CalculateAttributeCorrelation(string attributeName, Func<ContentPost, bool> attributePredicate)
            {
                var postsWithAttribute = allContent.Where(c => 
                    attributePredicate(c) && performanceByContent.ContainsKey(c.Id)).ToList();
                    
                var postsWithoutAttribute = allContent.Where(c => 
                    !attributePredicate(c) && performanceByContent.ContainsKey(c.Id)).ToList();
                
                if (postsWithAttribute.Count < 3 || postsWithoutAttribute.Count < 3)
                {
                    // Dados insuficientes para correlação confiável
                    correlations[attributeName] = 0;
                    return;
                }
                
                // Calcular performance média com o atributo
                double avgScoreWith = postsWithAttribute
                    .Average(c => CalculateOverallContentScore(performanceByContent[c.Id]));
                    
                // Calcular performance média sem o atributo
                double avgScoreWithout = postsWithoutAttribute
                    .Average(c => CalculateOverallContentScore(performanceByContent[c.Id]));
                    
                // Calcular "correlação" como diferença proporcional
                // Valores positivos indicam que o atributo está associado a melhor performance
                correlations[attributeName] = (avgScoreWith - avgScoreWithout) / 
                    Math.Max(0.01, (avgScoreWith + avgScoreWithout) / 2);
            }
        }

        private Dictionary<string, double> IdentifyHighPerformingFormats(
            List<ContentPost> topPosts, 
            Dictionary<Guid, ContentPerformance> performanceByContent)
        {
            var formatScores = new Dictionary<string, (double TotalScore, int Count)>();
            
            // Analisar cada post de alto desempenho
            foreach (var post in topPosts)
            {
                if (!performanceByContent.ContainsKey(post.Id)) continue;
                
                var performance = performanceByContent[post.Id];
                var score = CalculateOverallContentScore(performance);
                
                // Gerar descrição do formato
                string formatDescription = post.Format.ToString();
                
                // Adicionar plataforma se disponível
                if (post.Platform != SocialMediaPlatform.None)
                {
                    formatDescription += $" em {post.Platform}";
                }
                
                // Adicionar duração para vídeo/áudio
                if ((post.Format == ContentFormat.Video || post.Format == ContentFormat.Audio) && 
                    post.Duration > TimeSpan.Zero)
                {
                    string duration = post.Duration.TotalMinutes >= 1
                        ? $"{post.Duration.TotalMinutes:0.0} min"
                        : $"{post.Duration.TotalSeconds:0} seg";
                        
                    formatDescription += $" ({duration})";
                }
                
                // Registrar o formato
                if (!formatScores.ContainsKey(formatDescription))
                {
                    formatScores[formatDescription] = (0, 0);
                }
                
                var current = formatScores[formatDescription];
                formatScores[formatDescription] = (current.TotalScore + score, current.Count + 1);
            }
            
            // Calcular pontuações médias e retornar
            return formatScores
                .Where(kv => kv.Value.Count > 0)
                .ToDictionary(
                    kv => kv.Key,
                    kv => kv.Value.TotalScore / kv.Value.Count
                );
        }

        private List<ContentPatternDto> IdentifyContentPatterns(
            List<ContentPost> topPosts,
            Dictionary<Guid, ContentPerformance> performanceByContent,
            List<TimingPatternDto> timingPatterns,
            List<TopicPatternDto> topicPatterns,
            List<FormatPatternDto> formatPatterns,
            List<StylePatternDto> stylePatterns)
        {
            var patterns = new List<ContentPatternDto>();
            
            // Padrão 1: Combinação de formato e estilo mais eficaz
            if (formatPatterns.Any() && stylePatterns.Any())
            {
                var topFormat = formatPatterns.First();
                var topStyle = stylePatterns.First();
                
                var matchingPosts = topPosts
                    .Where(p => 
                        p.Format.ToString() == topFormat.FormatName && 
                        p.ContentStyle == topStyle.StyleName &&
                        performanceByContent.ContainsKey(p.Id))
                    .ToList();
                    
                if (matchingPosts.Count >= 2)
                {
                    double avgEngagement = matchingPosts
                        .Average(p => performanceByContent[p.Id].Engagement);
                        
                    patterns.Add(new ContentPatternDto
                    {
                        PatternName = $"{topFormat.FormatName} com estilo {topStyle.StyleName}",
                        Description = $"A combinação de {topFormat.FormatName} com estilo {topStyle.StyleName} produz resultados consistentemente superiores",
                        ConfidenceScore = CalculateConfidenceScore(matchingPosts.Count),
                        AverageEngagement = avgEngagement,
                        ExampleContentIds = matchingPosts.Take(3).Select(p => p.Id.ToString()).ToList(),
                        Attributes = new List<string> 
                        { 
                            $"Formato: {topFormat.FormatName}",
                            $"Estilo: {topStyle.StyleName}" 
                        }
                    });
                }
            }
            
            // Padrão 2: Tópico mais engajante em determinado dia/hora
            if (topicPatterns.Any() && timingPatterns.Any() && timingPatterns[0].BestDays.Any())
            {
                var topTopic = topicPatterns.First();
                var bestDay = timingPatterns[0].BestDays.First();
                
                var matchingPosts = topPosts
                    .Where(p => 
                        (p.PrimaryTopic == topTopic.TopicName || 
                         (p.SecondaryTopics != null && p.SecondaryTopics.Contains(topTopic.TopicName))) &&
                        p.PublishedAt.DayOfWeek == bestDay &&
                        performanceByContent.ContainsKey(p.Id))
                    .ToList();
                    
                if (matchingPosts.Count >= 2)
                {
                    double avgEngagement = matchingPosts
                        .Average(p => performanceByContent[p.Id].Engagement);
                        
                    patterns.Add(new ContentPatternDto
                    {
                        PatternName = $"{topTopic.TopicName} publicado às {bestDay}s",
                        Description = $"Conteúdo sobre {topTopic.TopicName} publicado às {bestDay}s gera maior engajamento",
                        ConfidenceScore = CalculateConfidenceScore(matchingPosts.Count),
                        AverageEngagement = avgEngagement,
                        ExampleContentIds = matchingPosts.Take(3).Select(p => p.Id.ToString()).ToList(),
                        Attributes = new List<string> 
                        { 
                            $"Tópico: {topTopic.TopicName}",
                            $"Dia: {bestDay}" 
                        }
                    });
                }
            }
            
            // Padrão 3: Conteúdos com alta taxa de compartilhamento
            var highSharePosts = topPosts
                .Where(p => 
                    performanceByContent.ContainsKey(p.Id) && 
                    performanceByContent[p.Id].Shares > 0 &&
                    performanceByContent[p.Id].Reach > 0 &&
                    (double)performanceByContent[p.Id].Shares / performanceByContent[p.Id].Reach > 0.05)
                .ToList();
                
            if (highSharePosts.Count >= 3)
            {
                // Identificar atributos comuns
                var commonAttributes = new List<string>();
                
                if (highSharePosts.All(p => p.IsEmotional))
                {
                    commonAttributes.Add("Conteúdo emocional");
                }
                
                if (highSharePosts.All(p => p.IsEducational))
                {
                    commonAttributes.Add("Conteúdo educacional");
                }
                
                if (highSharePosts.All(p => p.HasCTA))
                {
                    commonAttributes.Add("Com call-to-action");
                }
                
                // Verificar formato comum
                var commonFormat = highSharePosts
                    .GroupBy(p => p.Format)
                    .OrderByDescending(g => g.Count())
                    .First();
                    
                if (commonFormat.Count() >= highSharePosts.Count * 0.7) // 70%+ têm o mesmo formato
                {
                    commonAttributes.Add($"Formato: {commonFormat.Key}");
                }
                
                double avgEngagement = highSharePosts
                    .Average(p => performanceByContent[p.Id].Engagement);
                    
                patterns.Add(new ContentPatternDto
                {
                    PatternName = "Conteúdo altamente compartilhável",
                    Description = "Conteúdo com alta taxa de compartilhamento, gerando alcance orgânico superior",
                    ConfidenceScore = CalculateConfidenceScore(highSharePosts.Count),
                    AverageEngagement = avgEngagement,
                    ExampleContentIds = highSharePosts.Take(3).Select(p => p.Id.ToString()).ToList(),
                    Attributes = commonAttributes
                });
            }
            
            // Padrão 4: Conteúdos com alta retenção (para vídeos)
            var highRetentionPosts = topPosts
                .Where(p => 
                    p.Format == ContentFormat.Video &&
                    performanceByContent.ContainsKey(p.Id) && 
                    performanceByContent[p.Id].ContentDuration.TotalSeconds > 0 &&
                    performanceByContent[p.Id].AverageViewDuration.TotalSeconds / 
                        performanceByContent[p.Id].ContentDuration.TotalSeconds > 0.7) // 70%+ retenção
                .ToList();
                
            if (highRetentionPosts.Count >= 2)
            {
                // Identificar atributos comuns
                var commonAttributes = new List<string>
                {
                    "Formato: Vídeo",
                    "Alta retenção de audiência"
                };
                
                // Verificar duração comum
                bool shortVideos = highRetentionPosts.All(p => p.Duration.TotalMinutes < 3);
                bool mediumVideos = highRetentionPosts.All(p => 
                    p.Duration.TotalMinutes >= 3 && p.Duration.TotalMinutes < 10);
                bool longVideos = highRetentionPosts.All(p => p.Duration.TotalMinutes >= 10);
                
                if (shortVideos)
                {
                    commonAttributes.Add("Vídeos curtos (<3 min)");
                }
                else if (mediumVideos)
                {
                    commonAttributes.Add("Vídeos médios (3-10 min)");
                }
                else if (longVideos)
                {
                    commonAttributes.Add("Vídeos longos (>10 min)");
                }
                
                double avgEngagement = highRetentionPosts
                    .Average(p => performanceByContent[p.Id].Engagement);
                    
                patterns.Add(new ContentPatternDto
                {
                    PatternName = "Vídeos com alta retenção",
                    Description = "Vídeos que mantêm a audiência assistindo por mais tempo, indicando conteúdo envolvente",
                    ConfidenceScore = CalculateConfidenceScore(highRetentionPosts.Count),
                    AverageEngagement = avgEngagement,
                    ExampleContentIds = highRetentionPosts.Take(3).Select(p => p.Id.ToString()).ToList(),
                    Attributes = commonAttributes
                });
            }
            
            return patterns;
        }

        private List<string> GenerateMonetizationOpportunities(
            List<ContentPost> allContent,
            Dictionary<Guid, ContentPerformance> performanceByContent,
            ContentCreator creator)
        {
            var opportunities = new List<string>();
            
            // Oportunidade 1: Conteúdo Premium
            opportunities.Add("Desenvolva conteúdo premium aprofundado, como guias e cursos, baseado nos seus tópicos de maior engajamento");
            
            // Oportunidade 2: Parcerias de Afiliados
            opportunities.Add("Identifique produtos relevantes para seu nicho e incorpore links de afiliados em conteúdos informativos e de revisão");
            
            // Oportunidade 3: Conteúdo Patrocinado
            opportunities.Add("Aborde marcas alinhadas com seus valores para parcerias patrocinadas, mantendo autenticidade e transparência");
            
            // Oportunidade 4: Produtos Digitais
            opportunities.Add("Crie templates, presets ou ferramentas digitais que resolvam problemas específicos da sua audiência");
            
            // Oportunidade 5: Comunidade Exclusiva
            opportunities.Add("Estabeleça uma comunidade exclusiva por assinatura oferecendo acesso a conteúdo exclusivo e interação privilegiada");
            
            // Oportunidade 6: Monetização por Plataforma
            opportunities.Add("Otimize sua estratégia para programas de monetização de plataformas, como Programa de Parceiros do YouTube e Fundo de Criadores do TikTok");
            
            // Oportunidade 7: Licenciamento de Conteúdo
            opportunities.Add("Explore oportunidades de licenciamento do seu conteúdo de maior desempenho para marcas e outros canais de mídia");
            
            return opportunities;
        }

        public Task<AudienceInsightsDto> GetAudienceInsightsAsync(Guid creatorId, DateTime startDate, DateTime endDate)
        {
            // Implementação básica para satisfazer a interface
            _loggingService.LogWarning($"Método GetAudienceInsightsAsync implementado parcialmente para {creatorId}");
            
            var insights = new AudienceInsightsDto
            {
                CreatorId = creatorId,
                TotalAudienceSize = 0,
                GrowthRate = 0,
                DemographicBreakdown = new Dictionary<string, double>(),
                KeySegments = new List<AudienceSegmentDto>(),
                InterestDistribution = new Dictionary<string, double>(),
                PlatformEngagement = new Dictionary<SocialMediaPlatform, double>(),
                EngagementPatterns = new List<string>(),
                ContentPreferences = new Dictionary<string, double>(),
                LoyaltyMetrics = new LoyaltyMetricsDto()
            };
            
            return Task.FromResult(insights);
        }
    }
} 